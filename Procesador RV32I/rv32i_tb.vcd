$date
	Mon Nov 25 02:21:02 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module rv32i_tb $end
$var wire 32 ! rd2_tb [31:0] $end
$var wire 32 " pc_tb [31:0] $end
$var wire 1 # memWrite_tb $end
$var wire 32 $ ALUResult_tb [31:0] $end
$var parameter 32 % DURATION $end
$var reg 32 & ReadData_tb [31:0] $end
$var reg 1 ' clk $end
$var reg 32 ( instruccion_tb [31:0] $end
$var reg 1 ) reset $end
$scope module UUT $end
$var wire 32 * ReadData [31:0] $end
$var wire 1 ' clk $end
$var wire 32 + instruccion [31:0] $end
$var wire 1 ) reset $end
$var wire 1 , zero $end
$var wire 1 - regWrite $end
$var wire 32 . rd2 [31:0] $end
$var wire 1 / pcSrc $end
$var wire 32 0 pc [31:0] $end
$var wire 2 1 immSrc [1:0] $end
$var wire 1 2 branch $end
$var wire 2 3 ResultSrc [1:0] $end
$var wire 1 # MemWrite $end
$var wire 1 4 ALUsrc $end
$var wire 32 5 ALUResult [31:0] $end
$var wire 3 6 ALUControl [2:0] $end
$scope module u_datapath $end
$var wire 32 7 ReadData [31:0] $end
$var wire 1 ' clk $end
$var wire 32 8 instruccion [31:0] $end
$var wire 1 ) reset $end
$var wire 1 , zero $end
$var wire 32 9 srcB [31:0] $end
$var wire 32 : rd2 [31:0] $end
$var wire 32 ; rd1 [31:0] $end
$var wire 32 < pcNext [31:0] $end
$var wire 32 = pc [31:0] $end
$var wire 2 > immSrc [1:0] $end
$var wire 32 ? immExt [31:0] $end
$var wire 32 @ Result_mux1 [31:0] $end
$var wire 2 A ResultSrc [1:0] $end
$var wire 32 B Result [31:0] $end
$var wire 1 - RegWrite $end
$var wire 32 C PCTarget [31:0] $end
$var wire 1 / PCSrc $end
$var wire 32 D PCPlus4 [31:0] $end
$var wire 1 # MemWrite $end
$var wire 1 4 ALUsrc $end
$var wire 32 E ALUResult [31:0] $end
$var wire 3 F ALUControl [2:0] $end
$scope module adder_contador_programa $end
$var wire 32 G op2 [31:0] $end
$var wire 32 H op1 [31:0] $end
$var reg 32 I res [31:0] $end
$upscope $end
$scope module adder_ext $end
$var wire 32 J op2 [31:0] $end
$var wire 32 K op1 [31:0] $end
$var reg 32 L res [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 M srcB [31:0] $end
$var wire 32 N srcA [31:0] $end
$var wire 3 O ALUControl [2:0] $end
$var reg 32 P result [31:0] $end
$var reg 1 , zero $end
$upscope $end
$scope module banco_registros $end
$var wire 5 Q a1 [4:0] $end
$var wire 5 R a2 [4:0] $end
$var wire 5 S a3 [4:0] $end
$var wire 1 ' clk $end
$var wire 1 - we $end
$var wire 32 T wd3 [31:0] $end
$var wire 32 U rd2 [31:0] $end
$var wire 32 V rd1 [31:0] $end
$upscope $end
$scope module contador_programa $end
$var wire 1 ' clk $end
$var wire 1 ) reset $end
$var wire 32 W pcNext [31:0] $end
$var reg 32 X pc [31:0] $end
$upscope $end
$scope module ext $end
$var wire 25 Y inm [24:0] $end
$var wire 2 Z src [1:0] $end
$var reg 32 [ inmExt [31:0] $end
$upscope $end
$scope module mux_alu $end
$var wire 32 \ e1 [31:0] $end
$var wire 32 ] e2 [31:0] $end
$var wire 1 4 sel $end
$var reg 32 ^ salMux [31:0] $end
$upscope $end
$scope module mux_contador_programa $end
$var wire 32 _ e1 [31:0] $end
$var wire 32 ` e2 [31:0] $end
$var wire 1 / sel $end
$var reg 32 a salMux [31:0] $end
$upscope $end
$scope module mux_memoria_datos_1 $end
$var wire 32 b e1 [31:0] $end
$var wire 32 c e2 [31:0] $end
$var wire 1 d sel $end
$var reg 32 e salMux [31:0] $end
$upscope $end
$scope module mux_memoria_datos_2 $end
$var wire 32 f e1 [31:0] $end
$var wire 32 g e2 [31:0] $end
$var wire 1 h sel $end
$var reg 32 i salMux [31:0] $end
$upscope $end
$upscope $end
$scope module unidad_control $end
$var wire 1 / PCSrc $end
$var wire 3 j f3 [2:0] $end
$var wire 7 k f7 [6:0] $end
$var wire 7 l op [6:0] $end
$var wire 1 , zero $end
$var wire 1 - regWrite $end
$var wire 1 # memWrite $end
$var wire 1 m jump $end
$var wire 2 n immSrc [1:0] $end
$var wire 1 2 branch $end
$var wire 1 4 aluSrc $end
$var wire 2 o ResultSrc [1:0] $end
$var wire 3 p ALUcontrol [2:0] $end
$var wire 2 q ALUOp_wire [1:0] $end
$scope module alu_decoder $end
$var wire 3 r f3 [2:0] $end
$var wire 7 s f7 [6:0] $end
$var wire 7 t op [6:0] $end
$var wire 2 u aluOp [1:0] $end
$var reg 3 v aluControl [2:0] $end
$upscope $end
$scope module main_decoder $end
$var wire 7 w op [6:0] $end
$var reg 2 x ALUOp [1:0] $end
$var reg 1 4 ALUSrc $end
$var reg 1 m Jump $end
$var reg 2 y ResultSrc [1:0] $end
$var reg 1 2 branch $end
$var reg 2 z immSrc [1:0] $end
$var reg 1 # memWrite $end
$var reg 1 - regWrite $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101110111000 %
$end
#0
$dumpvars
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
xm
bx l
bx k
bx j
bx i
xh
b100 g
bx f
bx e
xd
bx c
bx b
b100 a
bx `
b100 _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
b0 X
b100 W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
b0 J
b100 I
b0 H
b100 G
bx F
bx E
b100 D
bx C
bx B
bx A
bx @
bx ?
bx >
b0 =
b100 <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
bx 3
x2
bx 1
b0 0
x/
bx .
x-
x,
bx +
bx *
1)
bx (
0'
bx &
bx $
x#
b0 "
bx !
$end
#500
1'
#1000
0'
0)
#1500
b1000 <
b1000 W
b1000 a
b1000 D
b1000 I
b1000 _
b1000 g
b100 "
b100 0
b100 =
b100 H
b100 J
b100 X
1'
#2000
b11 B
b11 T
b11 i
b11 @
b11 e
b11 f
0/
0h
0d
0,
b11 $
b11 5
b11 E
b11 P
b11 b
b111 C
b111 L
b111 `
b11 9
b11 M
b11 ^
0m
b10 q
b10 u
b10 x
02
b0 3
b0 A
b0 o
b0 y
0#
14
b0 1
b0 >
b0 Z
b0 n
b0 z
1-
b0 6
b0 F
b0 O
b0 p
b0 v
b0 ;
b0 N
b0 V
b11 ?
b11 K
b11 [
b11 ]
b10011 l
b10011 t
b10011 w
b0 j
b0 r
b0 k
b0 s
b0 Q
b11 R
b1000 S
b110000000001000 Y
0'
b1100000000010000010011 (
b1100000000010000010011 +
b1100000000010000010011 8
#2500
b1100 <
b1100 W
b1100 a
b1100 D
b1100 I
b1100 _
b1100 g
b1011 C
b1011 L
b1011 `
b1000 "
b1000 0
b1000 =
b1000 H
b1000 J
b1000 X
1'
#3000
b1 B
b1 T
b1 i
b1 @
b1 e
b1 f
b1 $
b1 5
b1 E
b1 P
b1 b
b1001 C
b1001 L
b1001 `
b1 9
b1 M
b1 ^
b1 ?
b1 K
b1 [
b1 ]
b1 R
b1001 S
b10000000001001 Y
0'
b100000000010010010011 (
b100000000010010010011 +
b100000000010010010011 8
#3500
b10000 <
b10000 W
b10000 a
b10000 D
b10000 I
b10000 _
b10000 g
b1101 C
b1101 L
b1101 `
b1100 "
b1100 0
b1100 =
b1100 H
b1100 J
b1100 X
1'
#4000
b11 B
b11 T
b11 i
b11 @
b11 e
b11 f
b11 $
b11 5
b11 E
b11 P
b11 b
b10101 C
b10101 L
b10101 `
04
b11 6
b11 F
b11 O
b11 p
b11 v
b11 ;
b11 N
b11 V
b1 !
b1 .
b1 :
b1 U
b1 \
b1001 ?
b1001 K
b1001 [
b1001 ]
b110011 l
b110011 t
b110011 w
b110 j
b110 r
b1000 Q
b1001 R
b101 S
b10010100011000101 Y
0'
b100101000110001010110011 (
b100101000110001010110011 +
b100101000110001010110011 8
#4500
b10100 <
b10100 W
b10100 a
b10100 D
b10100 I
b10100 _
b10100 g
b11001 C
b11001 L
b11001 `
b10000 "
b10000 0
b10000 =
b10000 H
b10000 J
b10000 X
1'
#5000
b0 B
b0 T
b0 i
1,
b0 @
b0 e
b0 f
b0 $
b0 5
b0 E
b0 P
b0 b
b10000 C
b10000 L
b10000 `
b0 9
b0 M
b0 ^
b0 q
b0 u
b0 x
1#
14
b1 1
b1 >
b1 Z
b1 n
b1 z
0-
b0 6
b0 F
b0 O
b0 p
b0 v
b0 ;
b0 N
b0 V
b11 !
b11 .
b11 :
b11 U
b11 \
b0 ?
b0 K
b0 [
b0 ]
b100011 l
b100011 t
b100011 w
b10 j
b10 r
b0 Q
b1000 R
b0 S
b10000000001000000 Y
0'
b100000000010000000100011 (
b100000000010000000100011 +
b100000000010000000100011 8
#5500
b11000 <
b11000 W
b11000 a
b11000 D
b11000 I
b11000 _
b11000 g
b10100 C
b10100 L
b10100 `
b10100 "
b10100 0
b10100 =
b10100 H
b10100 J
b10100 X
1'
#6000
0'
